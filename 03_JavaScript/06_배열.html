<!DOCTYPE html>
<html lang="en">
<head>
    <title>자바스크립트에서 중요한 거 두 개 배열이랑 객체랑</title>

    <style>

        .area {
            width: 500px;
            border: 1px solid lightpink;
        }

        .big {
            height: 500px;
        }

        .small {
            height: 300px;
        }

        button {
            border: 1px solid palevioletred;
            background: lightcoral;
            color: white;
            font-weight: 900;
            font-size: 19px;
            width: 150px;
            height: 60px;

            &:hover {
                background: salmon;
                cursor: pointer;
            }
        }

    </style>

</head>
<body>

    <p>
        여러 개의 값을 담기 위해 사용하는 자료형 <br />
        
        자바스크립트에서는 변수 선언 시 별도의 타입을 지정하지 않기 때문에 <br />
        배열도 const로 선언함!(딴거 없다고 생각하쇼 걍 const)
    </p>

    <!-- button#btn1+#area1.area.small -->
    <button id="btn1">버튼</button>
    <div id="area1" class="area small"></div>

    <script>

        // 버튼을 누르면 뭔가 하고싶을 때 가장 먼저 해야 할 일은 버튼에 접근
        // function을 다들 쓰고싶어하지 않음, 오타가 난다거나.. 그래서 잘 안쓰고 바꿔써보자
        // function 생략하고 소괄호 다음에 화살표(=>)로 작성 이게 익명함수, 요롷게 쓸 수 있음
        // 기능은 없고 문법만 이렇게, 성능좋아지고 이런것도 없음, 그냥 편하니꽈
        document.querySelector("#btn1").onclick = () => {

            // 배열의 선언 및 초기화(const로 선언할거라 선언하면서 초기화 해야함)
            // const array = new Object[10]; 자바로 따지면 이런 느낌
            const array = ["홍길동", 15, true, [1, 2]];
            // 여러개 담을 수 있고 자료형이 달라도 된다, 배열 안에 배열도 가능
            
            console.log(array);

            // 배열을 통째로 쓰는 경우는 별로 없죠..? 저 15만 사용하고싶다면?
            console.log(array[1]);

            // 배열 안에 있는 배열의 2만 쓰고싶다면?
            console.log(array[3][1]);
            // 이건 2차원배열이다!
            // 기본적으로 배열은 시퀀스라서, 엄밀히는 인덱스 안에 주소가 들어있다고 하는데, 속편하게 숫자가 들어있다고 가정하자
            // 배열 안의 배열은 면 형태로 인덱스가 또 0번, 1번 있는거겠지
            // 인덱스 3에 접근한다음에 그안의 1번 인덱스에 가야하는것
            // 그안에 또 배열이 들어있다면 3차원 배열이 되겠지. 그럼 그냥 또 가면되고

            // div 요소의 컨텐트 영역에 출력하고싶으면 제일 먼저 div 요소에 접근해야함
            const area = document.querySelector("#area1");

            // 이제 좀 자바스크립트 쓰는 사람들처럼 해보자
            /*
            area.innerHTML = `${array[0]} <br>`;
            area.innerHTML += `${array[1]} <br>`;
            area.innerHTML += `${array[2]} <br>`;
            area.innerHTML += `${array[3]} <br>`;
            */
            // 우리 배열 배우고 처음 한 게 반복문 쓰는거였쥬? 지금도 똑같은 로직을 반복해서 여러줄 작성함
            // 유일하게 다른 부분은 0, 1, 2, 3 -> 반복문의 제어변수로 처리할 수 있겠당

            // 반복문 for문
            // while은 버림ㅋ
            /*
            for(let i = 0; i < array.length; i++) { // 초기식, const로는 안된다, 증가해야하니까 -> let으로
                area.innerHTML += `${array[i]} <br>`;
            }
            */
            // 지금은 우리가 배열에 값을 넣겠지만 SQL로 DB에서 가져올것은 몇개일지 모를테니 이런식으로 반복문 써서 몇개든 니알아서 출력해세요

            // for in문
            // 초기식 조건식 증감식 쓰기 귀찮은 너낌이 있음 어차피 배열 요소만큼 다 돌건뎅
            // 자바에서도 for(String s : list) 이런거 했으니까 자바스크립트에도 이런거 있겠지?
            // for(let i in 순차적으로 요소에 접근할 배열)
            /*
            for(let i in array) {

                // i가 뭔지 일단 출력해보자, 뭔지 알아야 반복시킴
                // console.log(i); 요소 개수만큼의 index가 들어온다!
                // 그럼 앞이랑 똑같이 쓰면 되겠다
                area.innerHTML += `${array[i]} <br>`;

                // 얘도 순서가 보장되는 배열이라 앞에서부터 순서대로 나온다
                // 비교해보니 앞에서 쓴것보다 훨씬 간결해짐

            }
            */

            // for of문
            // 아무튼 for 시리즈 3종(for loop, for in, for of) 중에 젤 많이 쓰고 젤 편한거
            /*
            for(let value of array) {

                // 이것도 value가 뭔지 출력해본다
                // console.log(value);
                // 배열이 가지고 있는 요소가 하나씩 들어있음
                // 그럼 index에 구애받지 않고 뽑힌 요소 자체를 바로 사용가능
                area.innerHTML += `${value} <br>`;

                // 배열의 요소 앞에서부터 차곡차곡 접근

            }
            */

            // for each문도 있는데 선생님이 안좋아해서 안하신다는건 농담이고 잘 안써서 안함

            console.log("----------이게맵이다----------");

            // 고급 함수
            // 세개 꼭 해야함

            // map의 인자로 익명함수를 넣어준다
            /*
            const mapArray = array.map(function(e) {

                // array는 배열, 배열에 있는 요소를 익명함수에 매개변수를 만들어서
                // map 함수가 순차적으로 돌면서 요소 하나하나에 접근하도록 한다
                console.log(e);
                // return e; // 나중에 map을 반환할 수 있는데, 반환하면 뭐가 반환되냐면, 배열이 반환됨
                // 요소들을 앞에서부터 차곡차곡 담은 배열이 반환됨

                return `${e}<br>`;
                // 이런 문자열들이 담긴 배열이 반환됨, 배열의 요소가 하나씩 담긴 배열이 새로 만들어진것

            });

            console.log(`map으로 반환받은 배열 : ${mapArray}`);
            // 보통 map을 이용해서 내가 원하는 형태로 요소들을 변환해서 그걸 담은 배열로 반환시킴

            // 지금 우리도 각 요소 뒤에 <br> 태그를 붙여서 받고싶으니까 return을 할 때 `${e}<br>`로 수정
            */

            // 여기에 join이라는 메소드를 붙일 수 있음
            /*
            const str = array
                .map(function(e) {
                    console.log(e);
                    return `${e}<br>`;
                })
                .join("");
                // join은 배열의 요소를 하나의 문자열로 합쳐주는 메소드
                // 콘솔에 하나의 문자열로 출력됨(,로 구분했던것들이 쭉 붙어버림)

            // console.log(`map으로 반환받은 문자열 : ${str}`);
            // 그럼 이 문자열로 한번에 넣어버릴 수 있음
            area.innerHTML = str;
            // 이렇게 하면 요소를 반복하면서 요소를 가공해서 하나의 문자열로 만들어서 이걸 area content 영역에 쏙, 결과는 똑같음
            */

            // 익명함수니까 function을 생략하고 화살표로 바꿀 수 있음
            // map 함수 안에서 전달받은 인자로 return하는것밖에 없음
            // return만 한다면 중괄호와 return문을 생략할 수 있음
            /*
            const str = array.map((e) => `${e}<br>`).join("");
            area.innerHTML = str;
            */
            // 이건 다시 이렇게 쓸 수 있다
            area.innerHTML = array.map((e) => `${e}<br>`).join("");
            // for문 없이도 이렇게 한줄로 끝낼 수 있음

            // ??? 영상 3:06:00 부터 정리

            // 객체는 반복의 방법이 for of문밖에 없음

            // JQuery가 커리큘럼에 포함되어있는데 요새 거의 안씀
            // 사용기간이 길었음 15년 해먹음, 그래서 안할수는 없음, 유지보수를 위해 습득은 해야함
            // 얘는 반복시킬 때 for each로 함

            // 아무튼 자바스크립트는 순수바닐라 or for each or map or filter 네가지 기억
            // 익명함수 사용 시 일반적으로 function() {} 이렇게 안쓰고 람다로 씀
            // 기능적 차이는 없고 쓸게 줄고 보기 좋다(?) 뿐
            /*
                function() {
                
                }
                ==========>
                () => {
                
                }
                --------------------------------------------------
                function(a) {

                }
                ===========>
                a => {
                
                }
                --------------------------------------------------
                function(a, b) {
                
                }
                ==========>
                (a, b) => {
                
                }
                --------------------------------------------------
                function() {
                    return a;
                }
                ==========>
                () => a
            */

            // 리액트가서는 람다 쓸거고 그전까지는 이것저것 섞어쓰자

        };

    </script>

    <hr />

    <h3>* 배열의 선언</h3>

    <p>
        빈 배열을 선언 할 때, 크기를 지정할 수 있음 <br />
    </p>

    <button onclick="defArray();">버튼</button>
    <div id="area2" class="area small"></div>

    <script>

        // ??? 17:21 얘도 호출이 아니라 다른방법이 있는데 굳이 안하심
        function defArray() {

            // 배열 리터럴을 대입해서 선언하는 방법
            const array1 = []; // 권장사항

            const array2 = new Array(3); // 크기가 3 <== 쓰지말자
            // 이렇게 쓰는 사람도 있음
            // 이것도 배열을 만드는(선언하는) 방법인데, 권장사항과는 어마어마한 차이가 있음
            // 비슷하게 보이는데 array2는 empty X 3이라고 되어있음
            // 만들때 3칸짜리이고 lengh가 3이고 요소가 존재하지않음, 이걸로 반복한다면 문제가 생길수도
            // 옛날 코드를 보다가 이런걸 발견할수도 있지

            console.log(array1);
            console.log(array2);

            // 배열에 요소 추가
            // 자바에서 하던방식 : index에 접근해서 대입
            array1[0] = "사과";
            array1[1] = "바나나";
            array1[2] = "당근";
            // 처음에 크기(length)가 0이었는데도 문제가 일어나지 않고 그냥 배열에 요소가 추가됨

            document.querySelector("#area2").innerHTML = array1;
            // ??? 배열을 출력하면(innerHTML에 대입하고 출력) 요소가 콤마로 구분되어 나열됨
            
        };

    </script>

    <hr />

    <h3>* 배열용 메소드</h3>

    <h4>
        1) indexOf(찾고자하는요소) : 배열에서 해당 요소가 위치한 인덱스 반환
    </h4>

    <div id="area3" class="area small"></div>
    <button onclick="holiday();">빨간날찾기</button>

    <script>

        function holiday() {

            const days = [
                            "추석",
                            "개천절",
                            "설날",
                            "크리스마스",
                            "부처님오신날",
                            "현충일",
                            "광복절",
                            "어린이날",
                            "삼일절",
                            "한글날"
                         ];

            // console.log(days.indexOf("블랙프라이데이"));
            // 없는거 찾으니까 -1 나온다

            // 💗빨간날 찾기 버튼을 클릭하면
            //   사용자에게 텍스트를 입력 받아서(window.prompt())

            // 사용자가 입력한 텍스트가 배열의 요소로 존재할 경우
            // id가 area3인 div요소의 Content영역에
            // XXX(사용자가 입력한 텍스트)은(는) 빨간날이 맞습니다.

            // 사용자가 입력한 텍스트가 배열의 요소로 존재하지 않을 경우
            // id가 area3인 div요소의 Content영역에
            // XXX(사용자가 입력한 텍스트)은(는) 빨간날이 아닙니다.

            // 라고 출력해주세요.

            // 입력받기
            const day = prompt("무슨 빨간날을 찾으시나요??");
            // console.log(day);
            // 입력받아오기는 잘한다

            // 배열에 있는지없는지 확인 1. for문 2. 비교

            // 배열에 includes 메소드가 있음
            // console.log(days.includes(day));

            // 배운거로 하려면? indexOf의 인자로 넣음
            // console.log(days.indexOf(day));
            // 요소로 존재한다 == index(0이상의 정수)
            // 요소로 존재하지 않는다 == -1
            const index = days.indexOf(day);

            // 그럼 -1일때랑 그게아닐때랑 다르게 하고싶으니까 if문? 안쓰고싶은디요 -> 삼항연산자
            const result = index != -1 ? "맞습니다" : "아닙니다";

            document.getElementById("area3").innerHTML = `${day}는 빨간날이 ${result}`;

            /*
            const input = prompt("빨간날인지아닌지?");
            for(let i = 0; i < days.length; i++) {
                if(days.indexOf[i] == input) {
                    document.getElementById("area3").innerHTML = `${input}은(는) 빨간날이 맞습니다.`;
                } else {
                    document.getElementById("area3").innerHTML = `${input}은(는) 빨간날이 맞습니다.`;
                }
            }
            */

        };

    </script>

    <hr />

    <h3>참고사항</h3>

    <button onclick="remember();">알아두자</button>

    <script>

        function remember() {

            // 자바스크립트에서 동등비교
            console.log(1 == 1); // true
            console.log("1" == 1); // true

            console.log([] == 0); // 이게 대체 왜?? 둘 다 false로 취급되어서 동등하니 true가 됨

            // 자바스크립트에서 동등비교는 ==를 잘 쓰지 않음
            // === 이렇게 세개를 써보자
            // 이러면 값이랑 자료형이 둘다 동일한지 비교하게됨
            console.log("1" === 1); // false : 값, 자료형 둘다 일치해야만 true

            // 구조분해할당
            const array = ["Apple", "Banana", "Carrot"];

            // 배열에 들어있는 요소를 하나씩 뽑아서 쓰고싶을때가 있음
            /*
            const el1 = array[0];
            const el2 = array[1];
            const el3 = array[2];
            console.log(el1, el2, el3);
            */
            // 원래라면 하나씩 이렇게 뽑아서썼는데 별로 하고싶지않음 귀찮음

            // 이걸 쉽게해보자, 요소 세개를 이렇게 대입하기!
            const [el1, el2, el3] = array;
            console.log(el1, el2, el3);
            // 우왕 편하당 자바는 안됨 파이썬은 됨
            // 배열의 요소를 분해해서 사용할 수 있음

            /*
            const str = [...array];
            console.log(str);
            이건 다음에, 지금 예제로는 조금..?
            */

        };

    </script>

    <hr />

    <h4>2) concat(배열, 배열, 배열) : 여러 개의 배열을 합칠 때 사용</h4>

    <div id="area4" class="area big"></div>
    <div onclick="merge();">확인</div>

    <script>

        // ???
        function merge() {

            const array1 = ["가나다", "라마바"];
            const array2 = ["사아자", "차카타"];

            const area = document.querySelector("#area4");

            area.innerHTML = `${array1} <br>
                              ${array1.concat(array2)} <br>
                              ${array1} <br>`;
            // concat을 사용한다고 해서 원본 배열을 수정하는게 아니고
            // 두개의 배열 요소를 합친것을 새로운 요소로 반환해줌
            // 두개합친 배열을 사용하고싶다면
            const array3 = array1.concat(array2); // 이렇게 새로운 배열 받아서 사용해야함
            console.log(array3); // 통째로 하나의 배열을 만들어서 반환해줌

            // 배열 리터럴을 이용해서 넣으면 배열의 요소로 배열이 들어간 형태를 만들 수 있음
            // const array4 = [array1, array2];
            // console.log(array4);
            // 이렇게 넣는게 아니라 안에 있는 배열의 요소를 풀어서 담고싶다면 앞에 ... 추가
            const array4 = [...array1, ...array2];
            console.log(array4);
            // 이방법의 좋은점은 객체도 풀어헤칠수있음
            // concat은 배열에밖에 사용할 수 없지만
            // ...으로 풀어헤치기는 배열요소나 객체속성 둘다 풀어헤칠때 쓸 수 있는 방법이니 기억

        };

    </script>

    <hr />

    <h4>3) reverse() : 배열의 요소 순번을 역순으로 바꿔줌</h4>

    <div id="area5" class="area small"></div>
    <button onclick="arrayReverse();">리바스</button>

    <script>

        // ??? 9:33 호이스팅 안되니까 먼저 선언해서 써야함
        function arrayReverse() {

            const array = ["Apple", "Banana", "Melon", "Kiwi"];
            const area5 = document.getElementById("area5");
            area5.innerHTML = `${array} <br>`;

            array.reverse();
            // 이건 실제 배열이 영향을 받음
            area5.innerHTML = `${array} <br>`;
            // 얘는 원본배열이 바뀌어버림

            // 원본배열은 내버려두고싶다면? 배열을 복사해야함, 새 배열을 만들어서 작업해야함
            // const newArray = array; 이건 주소값이 복사되니까 얕은복사가 되어버림
            // concat, slice, map, filter reduce from 등의 방법이 많은데 보편적으로는 ... 이걸로 사용
            const newArray = [...array]; // 깊은 복사가 필요할 때 이렇게 spread 문법으로 새배열을 만들어서 사용함

        };

    </script>

    <hr />

    <h4>4) sort() : 배열의 요소를 정렬해줌</h4>

    <!-- #area6.area.small+button{정렬해야지} -->
    <div id="area6" class="area small"></div>
    <button onclick="sort();">정렬해야지</button>

    <script>

        function sort() {

            const array = [
                "Banana",
                "Lemon",
                "Apple",
                "Kiwi",
                "Mango",
                "수박",
                "イチジク",
            ]; // 여러 형태의 값들을 넣어보자

            const area6 = document.getElementById("area6");
            // area6.innerHTML = `${array} <br>`;
            // 그냥 출력해보고

            // array.sort();
            // sort 한 다음에
            // area6.innerHTML = `${array} <br>`;
            // 다시 출력해보자, 영어, 일어, 한글(오름차순, 국가코드 빠른거 기준)
            // quick sort 메소드라 성능도 빠르고 좋음

            array.sort().reverse();
            // 내림차순을 하려면 reverse 사용 --> sort() 뒤에 .reverse(); 추가
            area6.innerHTML = `${array} <br>`;

            // ??? 9:45

        };

    </script>

    <hr />

    <!-- ??? -->

    <h4>
        5_1) push(추가할요소) 배열 가장 마지막에 인자로 전달된 요소를 추가하고
             크기를 반환
        5_2) pop() : 배열의 가장 마지막 요소를 뽑아내고 뽑은 요소를 반환
    </h4>

    <div id="area7" class="area big"></div>
    <button id="btn7">요소추가</button>

    <script>

        const btn = document.querySelector("#btn7");

        btn.addEventListener("click", () => {

            const area = document.getElementById("area7");
            const lunchMenu = ["샐러드", "짜장면", "김치찌개", "돈까스"];

            area.innerHTML = `${lunchMenu} <br>`;

            // 이 배열에 점심 메뉴를 추가하고 싶을 수 있지
            const newMenu = prompt("추가할 메뉴를 입력해주세요~");

            // newMenu가 잘 들어오는지 확인
            // console.log(newMenu);

            lunchMenu.push(newMenu);

            area.innerHTML += `요소가 추가된 점심메뉴 : ${lunchMenu} <br>`;

            // 시시하니까 이중에 랜덤뽑기 ㄱㄱ
            // 배열의 index 만큼만 만들어내야함
            const num = parseInt(Math.random() * lunchMenu.length);
            alert(`오늘의 점심 메뉴는 ${lunchMenu[num]} 당첨~`);

            // pop은 반대로 요소를 제거함, 가장 마지막 index에 있는것을 제거해버림
            area.innerHTML += `${lunchMenu.pop()} <br>`;
            // pop한 요소를 반환해준다

            // push / pop은 배열의 마지막 요소에 작업

            // 배열의 첫번째 요소에 작업하는 메소드도 있음
            // 6_1) unshift(추가할요소) : 0번 인덱스에 요소 추가
            // 6_2) shift() : 0번인덱스 요소 뽑아내기
            const salad = lunchMenu.shift();
            area.innerHTML += `풀뽑기 : ${salad} <br>`;
            lunchMenu.unshift(newMenu);
            area.innerHTML += `${lunchMenu} <br>`;

            // 기존 배열을 그대로 두고 작업하고 싶은 경우가 많이 생긴다
            // 새 배열을 만들어서
            const newLunchMenu = [...lunchMenu, "제육볶음"];
            // 기존배열의 요소는 spread 문법으로 풀어서 넣고, 새 요소를 넣어줌

        });

    </script>

    <hr />

    <!-- 배열의 문제, 요소를 제거하는 메소드가 없어서 다른 방법으로 제거해야함 -->
    <h4>
        7_1) slice(begin, end) : 배열의 요소를 추출해줌 <br />
        7_2) splice(begin, count, el) : 배열의 요소를 추출해서 제거 및 추가
        항상 인덱스를 넣어줘야함
        시작 끝 ??? 추가할값
    </h4>

    <div id="area8" class="area big"></div>
    <button onclick="goal();">목표</button>

    <script>

        function goal() {

            const area = document.getElementById("area8");

            const array = ["나는", "올 해", "다이어트", "하겠다"];

            area.innerHTML = `올해 목표 : ${array} <br>`;

            // slice를 이용하면 배열에서 특정 부분 요소만 반환받아(뽑아) 쓸 수 있음
            // 실질적으로 중요한 다이어트 하겠다 요걸 샥샥, 시작인덱스가 2, 끝인덱스가 3일것임
            // slice
            area.innerHTML += `slice결과 : ${array.slice(2, 4)} <br>`;

            // 올해의 목표 쉽지않군 올해가 아니라 내년으로 바꾸고싶다, 아니면 특정요소를 제거해주고싶다
            // 근데 딱히 제거해주는 메소드는 없고 그럴 때 쓰는 게 splice
            // splice
            area.innerHTML += `splice : ${array.splice(1, 1)} <br>`;
            // 두번째 인자로 몇개 자를건지, 올 해 부분만 자를거니까 요소 한개, 1
            area.innerHTML += `${array} <br>`;

            // 제거 말고 특정 위치에 뭔가 추가하고 싶음, 올해말고 내년에 해야지
            // 똑같이 splice 쓰는데
            area.innerHTML += `??? : 이거왜안나옴 ${array.splice(1, 0, "내년에")} <br>`;
            // 1번 인덱스에, 하나도 안지우고(0), "내년에" 요소를 추가해야지 라고 인자전달
            // 이러면 지우지는 않고 배열이 가진 요소가 바뀐다
            area.innerHTML += array;

            // ??? 뭔가 이상해!

        };

    </script>

    <hr />

    <h4>
        8) join(구분자)
        : 배열에 담긴 요소들을 하나의 string타입 문자열로 합쳐주는 메소드
    </h4>

    <div id="area9" class="area small"></div>
    <button onclick="join();">버튼</button>

    <!-- join 자체는 크게 어렵지 않은데 -->

    <script>

        function join() {

            const area = document.querySelector("#area9");

            const arr = ["A", "P", "P", "L", "E"];
            // console.log(arr);

            // 배열 작성 스타일
            // 배열 마지막 요소 뒤에 , 를 붙이는 경우가 있음
            // 지금처럼 초기화하면서 넣을 때 말고
            // 요소들 세로로 한줄씩 넣을 때 마지막 요소 뒤에 붙이는 경우가 있음(아까 과일넣는거)
            // trailing 또는 후행 comma라고 부름
            // 가로로 쓸때는 안붙임
            // 나중에 유지보수를 위함
            // 깃허브에 올릴텐데
            // 배열에 요소를 추가할수도 있음, 콤마가 없었다면 변동사항이 두줄이 되는데
            // 이미 있던 콤마는 두고 추가한 요소 다음에 콤마만 넣으면 변동사항이 한줄이 됨
            // 변동사항 많으면 보기 힘드니까 이렇게 작성해주면 보기 편해짐

            // 얘네를 합쳐서 문자열로 쓰고싶다
            area.innerHTML = `${arr} <br>`;
            area.innerHTML += `${arr.join()} <br>`;
            // 똑같아보이는데 join을 쓸 때 구분자를 쓸 수 있음, 무엇을 가지고 합쳐줄건지
            // join메소드는 , 를 가지고 문자열로 합쳐주기 때문에
            // 구분자를 지정해줄 수 있음
            area.innerHTML += `${arr.join("")} <br>`;

            // 자바스크립트의 객체도 배열처럼 여러개 담고싶어서 쓰는녀석
            // 배열은 대괄호, 객체는 중괄호
            const obj = {
                과일: "APPLE", // key-value 쌍으로 데이터를 담음
            };

            console.log(obj); // 앞의 object는 자료형, 뒤의 Object는 어떤것을 상속받았는지의 prototype
            area.innerHTML += `${obj} <br>`;

            // 배열도 자바스크립트에서도 객체임
            // 근데 배열은 잘 찍히는데 객체는 이상하게 찍힘?
            // 배열을 HTML요소에 출력할 경우(innerHTML이나 alert이나 다른 요소에 넣는 경우들)
            // div.innerHTML = arr 이런식으로 할텐데
            // println(참조자료형변수); 자바에서 이렇게 하던거랑 똑같은거임
            // 자바에서 무슨 일이 일어남? .toString() 메소드 결과가 나오는것
            // 그래서 맨날 VO에도 object의 toString override 해놨지
            // 자바스크립트도 똑같음
            area.innerHTML += arr.toString(); // 그냥 arr 했지만 사실 이게 작동함, 내부적으로는 toString 호출결과가 찍히는것, 자바랑 똑같음
            // 우리가 선언한 obj는 toString이 없으니 부모(Object)의 toString을 호출해서 나오니까 이렇게됨

        };

    </script>

</body>
</html>