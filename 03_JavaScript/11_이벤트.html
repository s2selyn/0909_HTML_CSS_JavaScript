<!DOCTYPE html>
<html lang="en">
<head>
    <title>이벤트</title>
    <!-- ??? 아무래도 자바스크립트 이용하는 이유의 대부분을 차지하지않을까? -->

    <style>
        .area {
            background-color: beige;
            border: 1px solid palegoldenrod;
            height: 100px;
        }

        .style {
            background-color: yellowgreen;
        }
    </style>
</head>
<body>
    
    <h1>이벤트</h1>

    <!-- 자바스크립트입장에서도브라우저에서이벤트를하면좋아요? -->
    <!--
        * 이벤트 관련 용어정리

        event : 브라우저에서 발생하는 사건(동작, 행위)
        켜진거, 스크롤, 클릭 등 죄다 모든게 사건(이벤트)

        event target : 이벤트가 일어날(난) 객체(button, label, h1 등)
        보통은 버튼가지고 많이했음 클릭했던거, 현재 이벤트가 일어난 친구

        event type : (무슨이벤트냐) 이벤트 종류(click, mouseover, scroll, keydown)

        event listener : event를 감지하다가 감지되면 event handler를 수행

        event handler : 이벤트가 발생했을 때 동작할 코드들의 집합(뭉치)

        * 이벤트 모델 종류(이벤트에 핸들러를 달아주는 방법이 여러개)
        1. 고전 이벤트 모델 => 요소객체.onclick = 이벤트핸들러
        2. 인라인 이벤트 모델 => <요소 onclick="함수();"></요소>
        3. 표준 이벤트 모델 => 요소.addEventListener();

        JS로 리스너 달아주는 경우가 많으니까 다 써보고 어떤 차이 있는지 알아보자
    -->

    <h3>* 고전 이벤트 모델(기본 이벤트 모델)</h3>
    <!-- 이건 어감이 안좋은거고 사용하기 안좋은건아님, 하지마라 나쁘다가 아니고 그냥 하나의 방법일뿐 -->
    <!-- 고전이벤트라고 하니까 사람들이 거부감 느끼는것 같아서 기본이라고 함 -->

    <p>
        해당 요소객체의 이벤트 속성에 접근한 후 <br />
        이벤트 핸들러를 대입하는 방식 <br /><br />

        [ 표현법 ]
        객체명.(이벤트)속성명 = () => {} <br />
        => null을 대입하면 이벤트가 제거됨
    </p>

    <button id="btn1">뻐어튼</button> <br />
    <button id="btn2">뻐어튼</button>
    <div id="area1" class="area"></div>

    <script>
        const area1 = document.querySelector("#area1");
        /*
            querySelector VS getElementById

            * 일반적으로 querySelector를 권장함
            뒤에 CSS 선택자를 쓰기 때문
            getElement시리즈는 메소드이름을 봐야하는데 querySelector는 소괄호만 봐도 알수있고
            CSS 선택자를 그대로 쓸 수 있어서 유연하고 범용성이 좋고 한눈에 보기 좋음(자식 선택자도 쓸수있게됨)
            코드 전체 통일성도 생김(선택자를 이걸로 쓰니까)
            근데 항상 권장하는건 아님

            * 성능이 필요한 시점(웹페이지의 JS속도 최적화해야하는상황)엔 getElementById 더 빠를 수 있음
            querySelector는 들어온 선택자가 어떤 선택자인지 판단하는 연산이 필요함(범용적, 통일성 생각)
            getE는 그 연산이 필요없음
            그래서 미세하게라도 올리려면 getE를 사용

            둘중에 뭘쓰든 상관없긴 한데 쓰는 데 이유를 붙여야지
            누가 물어보면 답할 내용은 있어야겠죠
            기술의 선택에는 항상 이유가 있어야함, 이유없이 쓰면 따라쳤다고 생각함
            선택지가 여러개인 상황에서 뭔가를 골랐다면 반드시 이유가 필요함, 사소한거라도
            편해서 썼다고 해도 괜찮으니까 나의 답이 있어야함, 고급지고 어려운거보단 내 생각이 포함되어야겠지
            코드치는거야 몇달하면 누구나 할수있으니까
        */

        // 버튼에 기본방식으로 이벤트 부여해보자
        // target(이벤트가 발생할 객체)에 접근하기
        const btn1 = document.getElementById("btn1");
        // 수업이니까 여러개 섞어쓰는거고 나혼자 작업하면 내작업에서는 통일
        // 팀작업이라면 팀작업에서는 통일

        // eventtype을 지정
        btn1.onclick = function() { // eventHandler 대입

            // eventHandler 안에는 eventtype이 일어났을 때 어떤 작업을 할건지 작성
            area1.innerHTML += "btn1클릭<br>";

        };

        // 평상시에 안해본거 좀 해보자
        // btn2인 버튼을 클릭했을 때 btn1에게 달린 이벤트를 제거
        // 얘도 버튼 클릭했을 때 뭐 하고싶은거니까 btn2에 먼저 접근하는게 제일 먼저
        document.getElementById("btn2").onclick = () => {
            btn1.onclick = null;
            area1.innerHTML = "이벤트 없앴지 ~~";
        };

    </script>

    <hr />

    <h3>* 인라인 이벤트 모델</h3>
    <!-- CSS 생각하면 안좋을것 같지만 리액트에서도 이렇게 하니까 다 알아야함 -->

    <p>
        요소 내부에 직접적으로 이벤트 속성을 적어서 정의하는 방식 <br />
        주로 js모듈에 정의한 함수를 호출하는 방법을 선오
    </p>

    <!-- 출력도 하고 alert도 띄울 수 있음 -->
    <button onclick="document.getElementById('area1').innerHTML='클릭'; alert('띄워띄워')">극단적으로</button>
    <!-- 보기 힘들고 가독성이 떨어진다, 동작은 하지만 이런식으로 적는 경우는 잘 없음 -->

    <!--
        요소 내부에 직접 이벤트핸들러를 달아도 실행하는것에는 문제가 없지만
        내용이 길어지고 복잡하므로 ↑요렇게는 잘안함
        여러기능을 해야한다면 함수를 선언해서 호출하는 방식으로 사용함
    -->

    <hr />

    <h3>* 표준 이벤트 모델(addEventListener)</h3>

    <pre>
        [ 표현법 ]

        요소객체.addEventListener('이벤트명', 이벤트핸들러);
    </pre>

    <button id="btn3">이벤또~</button>

    <script>

        // 요소 선택 먼저
        const btn = document.getElementById("btn3");

        // 선택한 요소에 event listener를 추가하면서
        // 첫번째 인자로 이벤트 이름
        // 두번째 인자로 이벤트핸들러 전달
        btn.addEventListener("click", () => {
            alert("표준 이벤트 모델 테스트");
        });

        // 이름부터 표준이니까 얘가 권장사항임
        // 또 달고 싶다면 eventListener 추가하면됨
        // 고전은 onclick을 대입하는 방식이기 때문에 아래쪽에 추가하고싶어서 작성해도 맨 아래에 하나만 반영됨
        // 얘를 잘 사용하지 않았던 이유,, 리액트로 프로젝트 할건데 그땐 인라인 이벤트 모델로 할거라서
        // 아무튼 순수 자바스크립트 쓸때는 표준 이벤트 모델이 권장사항이니까 알아두쇼

        // mouseenter(hover 생각) : 포인터가 보더안으로 들어가는 순간
        btn.addEventListener("mouseenter", () => {

            // btn.style.backgroundColor = "yellowgreen";
            // 이렇게 하면 스타일이 인라인으로 들어가니까 뺄 방법이...? -> mouseout
            // 실제로 이런 작업은 요소에 바로 접근해서 하지는 않음

            // 스타일은 클래스 속성(선택자 이용)을 이용해서 전부 미리 만들어둔다
            // 그 다음에 스타일을 건드리는게 아니고 클래스 속성값을 추가함
            // 인라인은 우선순위가 높아서 기존 작업을 망가뜨릴수도 있음
            btn.classList.add("style");

        });

        // mouseout : 보더밖으로 포인터가 빠져나가는 순간
        btn.addEventListener("mouseout", () => {

            // btn.style.backgroundColor = null;

            // 마찬가지로 클래스 속성값을 제거하는 방식으로
            btn3.classList.remove("style");

        });
    </script>

    <hr />

    <h3>2. 현재 이벤트가 발생한 요소객체(이벤트타겟)에 접근하는 방법</h3>

    <button id="btn4">고전 이벤트 방식</button>
    <button id="btn5">표준 이벤트 방식</button>

    <button onclick="exFn(this);">인라인 이벤트 방식 1</button>
    <button onclick="exFn(this);">인라인 이벤트 방식 2</button>
    
    <script>

        // 각 이벤트 방식에 따라 이벤트핸들러에서 타겟에 접근하는 방법
        // 고전이나 표준은 쉽고 인라인이 메인, 해보긴해봄 복습하는느낌

        // 인라인 이벤트 모델
        // exFn 얘네가 실질적인 이벤트 핸들러가 되겠지(이벤트 타입은 onclick으로 달아두었음)
        function exFn(e) {

            // 버튼을 클릭했을 때 클릭한 요소의 컨텐트 값을 클릭됨!!으로 변경
            // 어제 함수 파트엥서 함수 호출 시 this 키워드 전달하는걸 했음, 매개변수로 전달한 인자값을 받아줌
            // this는 이벤트가 발생한 이벤트 타겟 객체를 전달함, 일반적으로 이런 상황에서 매개변수를 element의 앞글자를 따서 e라고 작성함
            console.log(e);

            // 동일한 함수를 호출하는 두곳에서 한곳은 되고 다른곳이 안된다면
            // 함수는 문제가 없고 둘중에 부르는 곳에서 잘못불렀다는 뜻이겠죠
            // 문제 발생했을 때 일어날 수 있는 원인 생각하기, 차곡차곡 찾아가서 고치기
            // 문제 발생한거 정리해서 자산으로 만드세요
            
            // 요소가 잘 넘어오니까 이 요소의 innerHTML 속성을 바꿔줌
            e.innerHTML = "클릭됨!";

        }

        // 고전 이벤트 방식
        // 요소객체에 접근부터 해야지
        document.getElementById("btn4").onclick = e => {

            // 원래라면 여기에서 또 선택했음.. 근데 그럴필요없고(번거로워서 일반적이지않음) 써보고 익히려고 한것
            // 먼저 이벤트 타입부터 알아보자!
            // window에 event라는 객체가 있음
            // console.log(window.event);
            // 브라우저나 버전에 따라서 PointerEvent 또는 MouseEvent로 나올 수 있음 -> 마우스로 발생된 이벤트라는 뜻
            // target 속성에 적힌 게 이벤트 타겟(발생시킨 애)
            // console.log(this.event);
            // 고전 이벤트 방식이면 this가 윈도우 객체를 의미하니까 똑같이 PointerEvent를 얻을 수 있음

            // event target을 알아내는 방법
            // console.log(window.event.target);
            // console.log(this.event.target);
            
            // 좀 귀찮아서 더 편한 방법을 선호하는데
            // ??? 15:05 매개변수가 큰 의미가 없음?
            // ()였던것을 e로 매개변수로 만들어줌
            // console.log(e);
            // PointerEvent가 반환된다
            // 그럼 얘도 e.target으로 작성하면 똑같이 온다
            // console.log(e.target);
            // 작성할걸 확 줄여버림

            // 그럼 방법이 세가지가 되겠죠
            window.event.target.style.background = "red";
            this.event.target.style.color = "white";
            e.target.innerText = "클릭했다능~~";

        };

        // 표준 이벤트 방식
        // 으로 접근하기
        document.getElementById("btn5").addEventListener("click", function(e) {

            // 위에랑 다른건 여기서 function 키워드가 붙어있음
            // 그럼 this 키워드가 무슨일을 하는지? -> 이벤트가 발생한 그 객체를 의미함
            console.log(this);
            // this 키워드의 쓰임새가 여럿이다
            // window.event.target == e.target
            // == this(function키워드가 붙은 함수)
            // == this.target(=>arrow function)
            // 인라인에서의 this는 자기자신을 의미
            // 외우지말고 그때그때 콘솔에 출력해서 확인하고 쓰쇼

            window.event.target.style.background = "black";
            e.target.innerHTML = "이벤트발생~~~";
            this.style.color = "white";
            // ???? 15:13 보편적으로 사용하는 방법이 뭐라고여?

        });

    </script>

    <hr />

    <h2>3. 태그별 기본적으로 달려있는 이벤트 제거하기</h2>

    <!-- 브라우저가 기본적으로 이벤트를 달아둔다, a태그, form태그 등 -->
    <p>
        기본적으로 이벤트를 가지고 있는 요소 <br />
        - a태그 : 클릭 시 href속성값으로 URL요청보내는 이벤트 달림 <br />
        - form 태그 안에있는 submit버튼 : <br />
        클릭 시 사용자가 입력한 값들을 action속성 값으로 요청 보내는 이벤트 달림
        <br /><br /><br />
    </p>

    <a href="http://www.naver.com" onclick="alert('하이');">네이버로~</a>
    <!--
    onclick 이벤트가 있음, 이거 없애고싶다면?
    내가 onclick을 추가해버리면 추가한거 먼저 실행되고 브라우저가 달아주는 이벤트가 수행됨
    -->

    <br />

    <a href="http://www.naver.com" onclick="return false;">네이버로</a>
    <!-- return false에 의해 다음에 일어날 이벤트를 컷! -->

    <!-- 방법 1. return false를 onclick속성에 넣어줌 -->

    <!-- 방법 2. 이거 하려면 함수가 하나 있어야함 -->

    <script>
        function returnFn() {

            if(1) { // if문 여기가 true이기 때문에
                return false; // 무조건 false가 반환된다
            } else {
                return true;
            }
        }
    </script>

    <!-- 특정 상황에서만 a태그가 동작하게 하고싶음 -->
    <a href="http://www.naver.com" onclick="returnFn();">너나가~</a>
    <!-- 이상태에서는 a태그가 동작한다. 분명히 returnFn이 false를 돌려보냈을텐데 -->
    <!-- 메소드 호출 시 반환값이 있다면 그것을 값으로 봐야한다! -->
    <a href="http://www.naver.com" onclick="return returnFn();">진짜 너나가~</a>
    <!-- 방법2. return 함수()호출 -->

    <br /><br /><br />

    <!-- HTML + CSS + JavaScript로 View를 만들고 사용자에게 값을 입력받을거란말이야 -->
    <!-- 회원 추가하려고 id, pwd 이런것들을 입력받아서 DB에 만들어둔 table에 insert했음 -->
    <!-- 테이블 만들 때 컬럼의 자료형, 제약조건이 있음 -->
    USER_ID VARCHAR2(15) UNIQUE NOT NULL
    <!--
    insert 하기 전에 USER_ID VARCHAR2(15) UNIQUE NOT NULL 이런게 있는데
    해당하지 않는다면 DB에 insert 안되니까 어차피 갈 필요가 없음, DB가면 돈드니까 그전에 컷해야함
    컬럼에 들어갈 수 있는 값인지 아닌지 검증하는 작업이 개발자가 해야할 일
    DB넣는거 insert 써서 MyBatis가 알아서 해줄텐데 insert에 100%실패할 값은 보내지 말고 개발자가 컷해야함
    검증 두번해야하는데 화면에서 하고 서비스에서 하고
    서비스는 나중에 하고 화면에서 하는거 먼저 할건데 HTML, CSS로는 할 수 없음
    방법은 JavaScript뿐
    -->

    <!-- 자바스크립트를 가지고 값에 대한 유효성 검사를 해보자 -->

    <form action="회원가입URL">

        <fieldset>

            <legend>회원가입</legend>

            <!-- 많이 하지말고 아이디가지고만 한다고 가정해보자 -->

            아이디 : <input type="text" name="userId" id="userId" /> <br />
            <!-- 나중에 서버에 요청보내려면 key역할을 하는 name 속성값이 필요함
            input요소의 value값을 검증해야하니까 얘를 선택할 수 있어야함, id 필요 -->

            <label style="font-size:10px; color: lightslategray">

                <!-- 개발자가 생각했을때의 조건 등 -->
                영문자 또는 숫자로만 5 ~ 12자 사이로 입력해주세요.

            </label>

            <br><br><br>

            <input type="submit" value="가입하기" onclick="return validate();" />
            <!-- 애초에 DB에 못들어갈 값이면 보낼게 아니라 여기서 알려줘야함, 사용자 편의를 위해서, 어차피 실패할거니까 -->
            <!-- submit에 유효성 검사 함수를 만들어서 추가 -->
            
        </fieldset>

    </form>

    <script>

        function validate() {

            // 유효성 검사 해주는 함수
            // 사용자가 입력한 아이디값이 유효한 값인지
            // 검사(확인)하는 함수
            // 유효하지 않은 값이라면 요청을 못가게 할거임

            // 사용자가 입력한 값을 검증하기 위해서는 사용자가 값을 입력하는 input요소에 접근하는게 제일 처음 해야할 일
            // value까지 한번에 빼보자
            const userId = document.getElementById("userId").value;

            // console.log(userId);

            // 영문자 or 숫자로만 + 5 ~ 12자 사이
            // 뭘 보고 체크해야함?
            // 비교대상 == 사용자가 입력한값(userId)
            // 검사할게 두가지, 한번에는 못함
            // 사용자가 입력한 값이 영문자 또는 숫자인가
            // 사용자가 입력한 값이 5 ~ 12자 사이
            // if가지고 생각하고 아니면 되돌리면되겠지?
            // 문제가 뭐야? 사용자가 입력한 문자 전부를 영어인지 숫자인지 체크할수있나?
            // 하나하나 뽑아서 영어인지 숫자인지 검사해서 입력한 길이(length)만큼 반복시킴
            // 만약에 영문자숫자를 먼저 검증하면 글자 많으면 할일이 많을텐데
            // 글자 길이수를 먼저 체크하면 암만 많아야 12번만 체크하면되겠다, 효율적일듯
            /*
            if(5 <= userId.length && userId.length <= 12) {

                // 이 안으로 들어온다면 길이조건 통과
                // 전체 문자열에서 한글자라도 영숫자가 아닌게 포함되면 안된다, 한글자씩 확인해야하지만 사용자가 얼마나 입력하는지 알수없음
                // 그래도 길이는 알 수 있다 -> 반복문을 쓸 수 있음
                for(let i = 0; i < userId.length; i++) {

                    // 처음부터 마지막까지 확인해야하니까 일단 뽑아야함
                    if(("a" <= userId.charAt(i) && userId.charAt(i) <= "z") ||
                       ("A" <= userId.charAt(i) && userId.charAt(i) <= "Z") ||
                       ("0" <= userId.charAt(i) && userId.charAt(i) <= "9")
                    ) {
                        return true;
                    }

                };

            };
            */

            // 아 좀 번거로운데?
            // 아이디 값에 대한 유효성 검사
            // 복잡하고 머리아픔 => 코드 읽을때도 힘들다(조건이 많고 반복도 낌)
            // 값에 대한 유효성 검사를 위해 정규표현식을 사용해보자
            // 동일한 로직을 돌리고 싶다
            // 영문자 또는 숫자로만 5 ~ 12자 사이

            // 변수 하나 선언, regular expression(정규표현식)
            // 슬래시 두개 사이에
            // 대문자 A부터 Z까지는 A-Z
            // 소문자 a부터 z까지는 a-z
            // 숫자 0부터 9까지는 0-9
            // 쭉 이어서 쓰고(구분자 없음) 대괄호로 묶음
            // 글자수 조건은 중괄호를 묶고 5글자부터 12글자 사이를 5,12로 작성(띄우면안됨)
            // 시작 슬래시 다음 캐럿, 끝 슬래시 앞에 달러사인
            const regExp = /^[A-Za-z0-9]{5,12}$/;
            // ??? 16:00 \w로도 가능??
            // console.log(regExp);
            // console.log(userId);
            // console.log(regExp.test(userId));

            // 패턴을 만족하는지 검사 => test()
            if(regExp.test(userId)) {
                return true;
            };

            // 중간에 확인하고싶은데 submit 당해버림 form 태그 요청 못하게 막으려면
            alert("엣헴!!! 어디 감히 조건을 만족하지 않고 보내려고 하느냐!");
            return false;
            // 이러고 함수호출부에 return 추가로 작성해둠
            // 유효한 값이면 나중에 return true; 하면된다

        }

    </script>

</body>
</html>