<!DOCTYPE html>
<html lang="en">

<head>
    <title>정표</title>

    <style>
        .area {
            height: auto;
            background-color: cornflowerblue;
            border: 1px darkblue;
            color: darkblue;
        }
    </style>
</head>

<body>

    <h1>정규표현식</h1>

    <p>
        정규표현식(Regular Expression : REGEX / REGEXP)이란, <br />
        특정 패턴을 가진 문자열을 찾거나 찾아서 변경할 때 사용하는 형식 언어
        <br />
        정규표현식을 사용하면 특정 조건검사를 하거나 변경할 때 <br />
        if문이나 for문을 사용하지 않고 간단하게 처리할 수 있음 <br />
        자바스크립트 뿐만 아니라 자바/오라클에서도 사용할 수 있음 <br />
        <!-- 문법은 똑같음 정규표현식 자체는 형식언어라서 -->
        <!-- 자바에서는 메소드로 사용할 수 있음 -->
        String클래스 ==> matches()

    </p>

    <!-- 형식언어는 또 뭐임, 문법인데, 만들어지는 언어, 법칙, 규칙이 있어서 컴퓨터로 찾거나 고칠 때 쓰는 언어
    얘만의 문법과 문법체계가 있음 -->
    <!-- 생긴게 좀 복잡해서 공부할것처럼 생겨서 자바하면서 머리아플까봐,
    실질적으로 가장 많이 사용하는 곳은 view라서 여기서함
    아무튼 자바나 오라클 둘다 사용할 수 있음
    실제로 개발할 때 필요하면 정규식 사이트에서 찾아쓰거나
    사람들이 정리해둔거, 정규식 예제 이런것들 보면됨, 만들어서 쓰는사람은 없고 가져다씀
    그래도 뭔지 알아야 갖다쓰면서 고치기도 하겠지 -->

    <hr />

    <div id="area1" class="area"></div>
    <button onclick="test1();">에밋문법은 신이다</button>

    <script>

        function test1() {

            // 정규표현식 사용하는 방법
            // 1. 정규식 객체 만들기

            // 정규식 객체 만드는 방법
            // 정규식 객체 생성자 함수를 호출한다
            let regExp = new RegExp("kh"); // 방법1
            regExp = /kh/; // 방법2 정규식 리터럴을 쓴다
            // 검색조건으로 삼고자하는 문자열 또는 패턴 제시

            // 2. 정규표현식을 이용해서 메소드를 호출
            // 만들고 메소드 호출하면 끝
            // 쓸만한 메소드들
            /*
                정규표현식객체가 제공하는 메소드들 => 정규객체.메소드명(문자열);
                - test(문자열) : 문자열에서 정규식값과 일치하는 값이
                있다면 true / 없다면 false
                - exec(문자열) : 문자열에서 정규식값과 일치하는 값이
                있다면 처음 매칭된 문자열 반환 / 없다면 null값을 반환

                보통은 test를 쓴다, 1000번중에999번
                execution의 약자인가?

                string객체에서 제공하는 메소드(정규식과 합체하면 강력해진다) => 문자열.메소드(정규객체);
                - match(정규식) : 문자열에서 정규식값과 "일치하는 값"을 반환
                진짜 많이 쓰는건 search, 활용도가 높음
                - search(정규식) : 문자열에서 정규식 값과 "일치하는 시작 인덱스"
                                  를 반환 / 없다면 -1을 반환
                - replace(정규식, 바꿀값) : 문자열에서 정규식 값과 일치하는
                첫 번째 값을 바꿀값으로 변경해서 반환
            */

            // 비교할 문자열
            const str1 = "samsung lg google kh apple amazon";
            const area = document.getElementById("area1");

            area.innerHTML += `regExp.test(str1) : ${regExp.test(str1)} <br>
                               ${regExp.test("asdfasdf")}`;
            // 정규표현식을 만족시키니까 true가 반환된다, 만족시키지 못하면 false

        }

    </script>

    <!-- 자바의 contains랑 비슷한데 어따쓸거임?
    실제로는 패턴을 만들어서 메타문자를 이용함 -->

    <hr />

    <h2>* 메타문자</h2>

    <p>
        메타문자를 사용해서 "검색조건으로 삼을 패턴"을 만들 수 있음 <br />
        => test() 통해 검사하거나 replace()를 이용해서 치환
    </p>

    <button onclick="test2();">실행</button>
    <div id="area2" class="area"></div>

    <script>

        function test2() {

            // div 요소에 접근
            const area = document.getElementById("area2");

            // 가벼운(?) 정규표현식 하나 만들어서 a
            let regExp = /a/;

            // 비교할 문자열
            const str = "javascript jquery ajax";

            area.innerHTML += `/a/ : ${regExp.test(str)} <br>
                               /a/ : ${str.replace(regExp, "*")} <br>`;
            // a가 포함되었으니 true, a가 포함된 친구중 제일 처음 a가 치환되어 출력됨

            // 메타문자
            // 1. ^ : 시작을 의미 => ^= 해당값으로 "시작"하는 경우
            // CSS 선택자에서 했음, 같은 의미
            regExp = /^j/; // 문자열이 소문자 j로 "시작하는 경우"

            // 내가 정규표현식으로 검사하는 문자열이 j로 시작한다면?
            area.innerHTML += `/^j/ : ${regExp.test(str)} <br>
                               /^j/ : ${regExp.test("gdfgdfgdf")} <br>`;
            // 우리 문자열은 j로 시작하고 아래는 그렇지 않으니까 각각 true / false
            // 만약에 이걸 if문으로 해결해야했다면?
            // if(str.charAt(0) === 'j') 이런식으로 처리해야했겠지

            // 2. [] : []안에 있는 문자 중 하나라도 존재할 경우
            regExp = /[abc]/; // 문자열 중 a또는 b또는 c가 하나라도 존재할 경우
            area.innerHTML += `/[abc]/ : ${regExp.test(str)} <br>
                               /[abc]/ : ${regExp.test("pppvvvfff")} <br>`;

            // 이런것들을 잘 섞어서 쓰면 됨
            // 문자열의 시작 문자가 j또는 s또는 a인가
            // if(str.charAt(0) === 'j' || str.charAt(0) === 's' || str.charAt(0) === 'a')
            // if라면 이랬겠지만 메타문자를 이용한다면?
            regExp = /^[jsa]/;
            area.innerHTML += `/^[jsa]/ : ${regExp.test(str)} <br>`;

            // 시작도 있으니 끝도 있겠지, CSS에서 쓴거랑 똑같음
            // 3. $ : 끝을 의미
            regExp = /x$/; // x로 끝나는지? 를 의미
            area.innerHTML += `/x$/ : ${regExp.test(str)} <br>`;

            // 시작은 j로 시작하고 끝글자는 x인지
            regExp = /^jx$/;
            // 웬만하면 시작 캐럿, 마지막 달러사인 이건 거의 무조건 붙이고 쓴다고 보면 된다
            // 왜냐하면 특정 문자를 쓸거면 그냥 스트링에서 서치를 쓰지 이걸 쓰지 않을것이므로
            // 패턴을 만들 때 항상 시작에 캐럿, 끝날 때 달러사인 이걸 쓴다
            // 근데 우리건 이렇게 쓰면 정규표현식 패턴을 만족할 수 없음
            // 이 것의 의미는, 이걸 만족할 수 있는 문자열은 하나뿐 -> jx
            area.innerHTML += `/^jx$/ : ${regExp.test(str)} <br>
                               /^jx$/ : ${regExp.test("jx")} <br>`;

            // 그러니까 시작과 끝을 만족하는 패턴을 작성하기 위해 추가적인 것들이 필요함
            // 체크를 할 때 수량 문제라든가 그런것들은 나중에 하기로 하고
            // 단순한 친구들 먼저
            // 4. . : 개행문자를 제외한 모든 문자를 의미(영어,숫자,한글,특문...)
            // 5. + : 한 글자 이상을 의미(0글자 X)

            // 시작부터 끝까지 오로지 숫자값으로만 이루어져있는가
            // 숫자라면 0123456789, 처음부터 끝까지 모두 체크하고싶은거니까 ^$로 감싸기
            // 숫자가 섞여있을 수 있음 234567, 64646464 등
            // 이런 상황에서는 어떤것이 앞에 먼저오든 상관없다는 의미로 대괄호로 묶음
            // 대괄호 뒤에 +를 붙여 -> 숫자의 개수는 상관이 없고 무조건 한 글자 이상이어야함
            regExp = /^[0123456789]+$/; // 숫자의 개수는 상관없음
            // 무조건 1글자 이상이어야 패턴 만족
            // 보통은 시작부터 끝까지 검사하고 싶을 때(모든 숫자를 다 검사하고 싶을 때)
            // 0123456789를 풀어서 쓰지 않고 [0-9], 0부터 5까지 보고싶다면 [0-5] 이런식
            regExp = /^[0-9]+$/; // 한글자 이상은 +, 0부터 9까지는 [0-9]
            // 이렇게 하면 한글자 이상이고 0부터 9까지만 포함이 되어있는가 체크하게된다
            area.innerHTML += `/^[0-9]+$/ : ${regExp.test("3242342342")} <br>
                               /^[0-9]+$/ : ${regExp.test("1,000")} <br>`;
            // 전부 숫자니까 위는 true, 콤마로 자리수 구분하면 숫자가 아닌게 껴있는 문자열이 되니까 false

            // 영어는 대문자도 있고 소문자도 있음
            // a부터 z까지 A부터 Z까지
            regExp = /^[a-zA-Z]+$/;
            // 문자열의 길이는 상관없음 최소한 한글자 이상이어야하고
            // 시작부터 끝까지 오로지 영문자(대문자, 소문자)로만 이루어진 패턴

            // 아까 아이디 검사한것처럼
            // 영문자, 숫자로만 입력하세요
            regExp = /^[a-zA-Z0-9]+$/;
            // 이것보다 더 단축하는 방법도 있음 좀이따가
            // if나 for 쓰던것을 정규표현식으로 깔끔하게 해결
            area.innerHTML += `/^[a-zA-Z0-9]+$/ : ${regExp.test("sdfsd434")} <br>
                               /^[a-zA-Z0-9]+$/ : ${regExp.test("sdfd한sdfsd")} <br>`;

            // 한국이니까 사이트 운영하다가 한글만 입력받는 경우도 있을것이여
            // 시작부터 끝까지 오로지 한글(자음, 모음, 결합)로만 이루어진 경우
            regExp = /^[ㄱ-ㅎㅏ-ㅣ가-힣]+$/;
            area.innerHTML += `/^[ㄱ-ㅎㅏ-ㅣ가-힣]+$/ : ${regExp.test("ㄴ어핳흫휕")}`;

        }

    </script>

    <hr />

    <h3>* 플래그문자</h3>

    <p>
        /정규표현식/ 뒤에 써줌 <br /><br />

        종류 <br />
        i : 대/소문자 전부 보겠다. <br />
        g : 문자열 내의 모든 패턴검사(전역으로 보겠다) <br />
        m : 여러 줄 비교를 수행하겠다.(개행 있어도)
    </p>

    <button onclick="test3();">빠른</button>

    <script>

        function test3() {

            // 비교할 문자열
            const str = "JavaScript jQuery AJAX";

            // 정규표현식 객체
            let regExp = /a/;
            console.log(str.replace(regExp, "ㅋㅋㅋ"));
            // 문자열 안에 a가 많은데... 제일 앞의 a만 패턴 만족되고 뒤의 a들은 만족되지 않아서
            // 앞의 a만 ㅋㅋㅋ로 치환됨
            // 아 참을 수 없다 뒤의 a도 웃겨버리고 싶음
            // 웹에서 욕설 필터링해서 바뀌어야되는데 제일 앞의 욕만 바뀌면 이상하자나여
            // 그럴 때 필요한게 이녀석들
            regExp = /a/g;
            console.log(str.replace(regExp, "ㅋㅋㅋ"));
            // 문제는 알파벳 대소문자가 있으니 소문자 a만 바뀜, A도 웃기고 싶음
            regExp = /a/gi; // i와 g의 순서는 상관없음
            console.log(str.replace(regExp, "ㅋㅋㅋ"));

            // 개행이 들어가있는 문자열은 g를 붙여도 체크되지 않을 수 있음
            // 그럴때는 m까지 붙여주면 된다, 모든게 포함된 여러줄 전부 정규표현식으로 검사가능

        }

    </script>

    <hr />

    <h3>* 정규표현식을 이용해서 주민번호 확인</h3>

    <!-- 예전에는 휴대폰 인증시스템이 없으니까 주민번호 입력해서 가입하는데, 진짜 주민번호가 이사람건지 검사하는게 아니라 주민번호 형식이 있는지를 검사해서
    주민번호 생성기로 가짜 주민번호를 이용하기도 했다
    이런것들을 정규표현식으로 어떻게 검사했는지 알아보자
    정규표현식 공부하기 아주죠쿠나
    옛날에는 가짜주민이 많았다네요, 진짜 이사람것인지 검증하는 시스템이 없어서.... -->

    주민번호 : <input type="text" id="pno" />
    <button onclick="test4();">확인</button>

    <script>

        function test4() {

            const value = document.getElementById("pno").value;

            // 주민번호 형식
            // 생년월일-성별지역순서랜덤값
            // 6-7

            // 1단계 : 6글자 - 7글자
            // . : 개행문자를 제외한 모든 문자 중 1개
            let regExp = /^......-.......$/; // 글자 수 체크 패턴
            // 글자수 14글자와 7번째가 짝대기인지 확인함

            // 2단계 : 숫자여야함
            regExp = /^[0-9][0-9][0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9][0-9][0-9][0-9]$/;
            // 와 이렇게 써야 함? 너무 힘든데

            // 편한 방법
            /*
                * 메타문자

                \d : 숫자 (==[0-9])
                \D : 숫자를 제외한 모든 문자
                \w : 영문자, 숫자, _(==[a-zA-Z0-9_])
                \W : 영문자, 숫자, _를 제외한 모든 문자
                \s : 공백문자만(스페이스, 탭, 개행문자)
                \S : 공백문자를 제외한 모든 문자
            */

            // 그럼 힘들게 쓸 필요가 없었군요
            regExp = /^\d\d\d\d\d\d-[1-4]\d\d\d\d\d\d$/;
            // 외국인은 실명인증 사이트 가입하려면 외국인증 있어야하니까
            // 국내만 받고싶다면 - 다음의 첫 숫자는 [1-4]

            // 아 똑같은거 왜계속씀? 편한거읎어?
            /*
                * 수량문자
                + : 최소한 한 글자 이상
                * : 0글자 이상(0글자 가능)
                ? : 0글자 또는 1글자(2글자 이상은 불가능)

                앞에도 6개, 뒤에도 6개 써야하는 이런 상황에서
                {6} : 6글자
                {2,5} : 2글자 이상 5글자 이하
                {2,} : 2글자 이상
                {,5} : 5글자 이하
            */

            regExp = /^\d{6}-[1-4]\d{6}$/;
            // 굉장히 간결해짐

            // 이왕 하는 김에 앞에 생년월일을 만져보자, 지금은 999999 이런게 들어올 수 있음
            // 이런건 막고싶다, 월 자리에는 01부터 12까지, 일 자리에는 01부터 31까지, 연도는 00부터 99까지 충분히 가능
            // 월일정도는 막아보자(윤달은 뺀다고 가정하고)
            // 3단계. 생년월일
            /*
                - 생년(두자리) : \d{2}
                - 월(두자리) : 앞자리가 0일 경우 뒷자리가 1 ~ 9까지 가능
                              앞자리가 1일 경우 뒷자리가 0 ~ 2까지 가능
                세번째 자리에 들어올 수 있는 수는 0 아니면 1(12월까지뿐이니까)
                거기다 세번째 자리의 값에 따라 뒤(네번째)의 값이 제한됨

                그룹핑(경우1|경우2)
                앞에 숫자 두자리는 \d{2}
                뒤에 숫자 두자리는 큰 경우 01 두개를 소괄호로 묶고 |로 구분
                0의 경우에 들어갈 네번째 값은 대괄호로 묶어서 작성[1-9]
                1의 경우에 들어갈 네번째 값은 대괄호로 묶어서 작성[0-2]
                \d{2} (0[1-9]|1[0-2])

                - 일(두자리) : 앞자리가 0일 경우 뒷자리가 1 ~ 9까지 가능
                              앞자리가 1/2일 경우 뒷자리가 0 ~ 9까지 가능
                              앞자리가 3일 경우 뒷자리가 0 ~ 1까지 가능
                0, 1, 2, 3으로 시작하는 네가지 경우, 그리고 뒷자리가 달라짐
                \d{2}(0[1-9]|1[0-2]) (0[1-9]|1[0-9]|2[0-9]|3[0-1])
                이걸보니 1이랑 2는 같음 -> [1-2][0-9]로 묶어줄 수 있다
                \d{2}(0[1-9]|1[0-2]) (0[1-9]|[1-2][0-9]|3[0-1])

                앞자리에 따라 뒷자리를 다르게 할건데 이럴 때 그룹핑
            */

            regExp = /^\d{2}(0[1-9]|1[0-2])(0[1-9]|[1-2][0-9]|3[0-1])-[1-4]\d{6}$/;
            // 이러고 끝? ㅇㅇ
            // 한번씩 써봤으니까 실제로 뭔가 필요해서 사용할때는 검색해서 찾아쓰면됨, 굳이 만들어서 쓸 필요 없음

        }

    </script>

</body>

</html>