<!DOCTYPE html>
<html lang="en">

<head>
    <title>쩔수없음 알긴 해야함</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>

    <style>
        .highlight-1 {
            background-color: aquamarine;
        }

        .highlight-2 {
            background-color: aqua;
        }

        .highlight-3 {
            background-color: dodgerblue;
        }

        .highlight-4 {
            background-color: darkcyan;
        }

        .highlight-5 {
            background-color: darkblue;
        }
    </style>
</head>

<body>

    <h1>jQuery쟁이들이 좋아하는 메소드들</h1>

    <h4>* each메소드</h4>
    <!-- 역사가 오랜 회사의 레거시 프로그램(괴물들), 과거로부터 물려받은것
    지금이랑 똑같이 동작하는데 언어가 코볼, 아니면 자바를 썼는데 버전이 JDK 6버전 등
    지금 배운 문법 50%는 못쓴다고 보면 된다, 수업시간에 다루는건 자바 8버전 이후(이걸 모던자바라고함)
    8 이전의 친구들은 안되는게 많다, 나중에 생긴 문법이 많음, 텍스트 블록(""" """) 12버전
    try with resource는 7버전, 자료형 선언할 때 제네릭은 앞에만 붙이는데 8 이전에는 뒤에 생성자 뒤에도 반드시 붙여야하는 문법
    회사는 이런 코드들을 딱히 고치지 않는다, 시간들고 돈들고 사람넣어야하니까, 굳이 잘돌아가는걸 바꿀 필요가 없다고 생각
    오래되고 근본있는 회사일수록 이런 괴물 코드들이 많이 있음, jQuery도 한 축이다, 15년간 인기있었던 자바스크립트 라이브러리
    점유율 90% 이상의 앞단 자바스크립트코드에 들어갔기 때문, 공부안할수는없다
    each메소드를 jQ쓰던 사람들이 아주 좋아하고 많이 썼음 -->

    <p>
        배열의 모든 인덱스에 순차적으로 접근해야할 때 <br />
        객체가 가지고 있는 모든 속성에 순차적으로 접근해야할 때 <br />
        사용할 수 있는 for문과 유사하게 수행되는 메소드
    </p>

    <pre>
        [ 표현법 ]

        1) $를 참조해서 each 메소드를 호출함
        첫번째 인자로는 반복적으로 접근하고 싶은 객체/배열(속성, 요소)
        두번째 인자로는 보통 함수, 매개변수 2개가 보통
        each의 가장 일반적인 방법
        $.each(객체/배열, function(매개변수1, 매개변수2){
            순차적으로 요소에 접근해서 수행할 내용;
        });

        2) 배열에 바로 참조해서 하는 방법도 있음
        배열.each(function(매개변수1, 매개변수2) {
            순차적으로 요소에 접근해서 수행할 내용;
        });

        ==> 매개변수1, 2는 생략 가능
        (하지만 이걸 쓴다는 것 자체가 매개변수를 사용해야하는 경우라서 생략하는 경우는 잘 없음)
        ==> 순차적으로 객체/배열의 속성이나 인덱스에 접근할 때마다 function
            수행
        ==================================================

        case 1) 객체의 경우
        매개변수 1: 순차적으로 접근한 객체의 속성명(Property)
        매개변수 2: 해당 속성값(Value)

        case 2) 배열의 경우
        매개변수 1: 순차적으로 접근한 배열의 인덱스(Index)
        매개변수 2: 해당 요소값(Value)
    </pre>

    <div id="area1">

    </div>

    <script>
        $(function () {

            // 배열을 생성
            const fruits = ["사과", "체리", "복숭아"];

            // ??? 10:08 설명!

            // for loop문
            for (let i = 0; i < fruits.length; i++) {
                console.log(`인덱스 : ${i}, 요소 : ${fruits[i]}`);
            };

            console.log("----------------------------------------");

            // for in문
            for (let index in fruits) {
                console.log(`인덱스 : ${index}, 요소 : ${fruits[index]}`);
            };
            // for loop, for in 둘 다 똑같이 나온다

            console.log("----------------------------------------");
            // 우리가 필요한건 뒤에 있는 배열에 들어있는 요소

            // for of문
            for (let fruit of fruits) {
                console.log(`요소 : ${fruit}`);
            };
            // 굳이 index 써서 접근할 필요없이 안써서 요소만 접근 가능

            console.log("----------------------------------------");

            // jQ에서는 이런 역할을 each메소드를 써서 할 수 있음
            // 두번째 인자로 콜백함수, 이 함수를 호출했을때의 결과를 each 메소드의 인자로 넣는것
            // ??? 10:11 다른함수의 호출결과를 함수의 인자로 넣는 것을 콜백함수라고 함
            $.each(fruits, function (index, value) {
                console.log(`인덱스 : ${index}, 요소 : ${value}`);
            });
            // jQ에서 반복할 때 each를 많이 쓴다, 네이버에서도 구경가능

            console.log("----------------------------------------");

            // 순수 바닐라 자바스크립트에 이런게 생겨버림
            fruits.map((el, i) => {
                console.log(`인덱스 : ${i}, 요소 : ${el}`);
            });
            // 고급함수라고 합니다, 훨씬 간결해보이네요, 이게 나온 이후로는 each를 굳이 써야하나 싶은거지
            // 특히 배열의 경우에

            console.log("----------------------------------------");
            // 객체로 가면 이야기가 좀 달라짐
            // ??? 10:15 객체는 반복문을 돌릴 수 없으니 for in으로 key값을 뽑아서 돌려야하는데
            // each는 배열처럼 객체도 가능
            // 객체를 제시했을 경우
            const capital = {
                한국: "한양",
                일본: "도꾜",
                중국: "베이찡",
                프랑스: "빠리",
            };

            $.each(capital, function (key, value) {
                console.log(`속성명 : ${key}, 값 : ${value}`);
            });
            // property가 key가 된다

            // 주로 자바스크립트에서 사용하는 경우는
            // 객체 배열
            // 배열의 요소로 객체가 들어있는 것
            const links = [
                { name: "네이버", link: "http://www.naver.com" },
                { name: "구글", link: "http://www.google.com" },
                { name: "다음", link: "http://www.daum.net" },
            ];

            const area1 = document.getElementById("area1");
            let output = "";
            $.each(links, function (index, item) {
                output += `<a href="${item.link}">${item.name}</a><br>`;
            });
            // ??? 10:23 동적인 요소 만들기?

            // div 요소에 만들어진 output을 대입
            // $("#area1").html(output);
            // 동적인 요소에 반복
            // 주로 이런 용도로, 객체배열을 반복시킬 때 사용

            $("#area1").html(
                // links.map(e => `<a href="${e.link}">${e.name}</a><br>`.join(""))
            );

        });
    </script>

    <hr />

    <br /><br /><br />

    <!-- table>(thead>tr>th*3)+tbody -->
    <!-- 데이터베이스의 회원정보 담는 테이블에 저장되어있을것임 -->
    <table border="1" id="areaT">
        <thead>
            <tr>
                <th>회원번호</th>
                <th>아이디</th>
                <th>가입일</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>

    <br /><br /><br />

    <button id="user-info">회원정보조회요청</button>

    <script>
        $(function () {

            $("#user-info").click(function () {

                // 서버에게 요청~
                // 아직 어떻게 하는 지 모르지만 클릭하면 서버에 요청이 간다고 가정
                // 요청을 보내고 나중에 어떤식으로 보여주나요?
                // DB로부터 데이터를 조회했다고 가정
                // 자바스크립트의 객체 배열 형태로!
                const members = [

                    // 실제 회원의 정보는 멤버 테이블에 저장되어있겠지
                    // 회원번호, 아이디, 가입일 등의 컬럼
                    // 한명의 회원에 대한 정보는 테이블의 하나의 행으로 들어있음

                    // 회원의 정보가 각각 행으로 들어있으니까, 하나의 회원정보를 하나의 VO객체로 가공하고
                    // 회원이 여러명이라면 리스트에 담아서 응답을 해주겠지
                    // 여기까지는 자바 얘기고

                    // 자바에서 다시 여기로 응답해줄텐데 그때는 하나의 회원정보가 하나의 자바스크립트객체형태로 받아올것
                    { memberNo: 1, memberId: "user01", enrollDate: "2025/09/22" },
                    { memberNo: 2, memberId: "user02", enrollDate: "2025/09/22" },
                    { memberNo: 4, memberId: "user22", enrollDate: "2025/09/22" },
                    // 여러개의 객체가 필요하기 때문에 자바스크립트의 배열로 받아오겠지
                    // 뷰에서 출력할 때 각 객체의 속성값을 가지고 HTML 컨텐트 영역에 넣어서 화면출력
                    // 동적 요소 만들어야함
                    // DB에 갔다오는데 객체가 몇개 있을지, 몇명 회원이 조회될지 알수없으니
                    // 반복문을 통해 요소에 순차적으로 접근해서 동적인 요소를 만들어서 화면에 출력

                ];

                let result = "";

                $.each(members, function (index, obj) {

                    // console.log(obj);
                    // 객체 전체가 아니라 객체 속성에 해당하는 값만 필요함
                    // 객체명.속성명 이렇게 객체가 가진 속성값에 접근함
                    result += `<tr>
                                    <td>${obj.memberNo}</td>
                                    <td>${obj.memberId}</td>
                                    <td>${obj.enrollDate}</td>
                               </tr>`;

                });
                // ??? 10:38 

                $("#areaT tbody").append(result);
                // 이렇게 DB에서 조회해온 내용을 출력
                // jQuery 메소드들이 중요하다기보단 객체의 속성에 접근하는 법 이런것들이 중요, 화면에 출력할 때 사용할것들

            });

        });
    </script>

    <hr />

    <!-- #wrap>h2{item-$}*5 -->
    <div id="wrap">
        <h2>item-1</h2>
        <h2>item-2</h2>
        <h2>item-3</h2>
        <h2>item-4</h2>
        <h2>item-5</h2>
    </div>

    <!-- 각 요소에 미리 만들어둔 스타일을 부여하기 위해 each 메소드 사용해보기 -->
    <script>

        // 네이버에서 본것처럼 특정요소의 자식 또는 부모 요소를 선택해서 사용하는 경우가 많다
        $(function () {

            // console.log($("#wrap").children());
            // jQuery로 선택하면 jQuery 객체 형태로 선택됨, 그럼 이걸로 each 메소드 사용 가능하다는 뜻
            $("#wrap").children().each(function (i, el) {

                // console.log(`속성명 : ${i}, 요소(속성에 해당하는 값) : ${el}`);
                // 요소객체기 때문에 toString이 [object HTMLHeadingElement] 이렇게 출력됨

                // 각 요소에 클래스 속성값을 추가해보자
                // console.log(el);
                // 이건 item 5총사가 출력됨
                
                // 만들어둔 스타일 1부터 5까지를 item 5총사에 순서대로 부여하고싶다
                // highlight-1 ~ 5
                // 요소의 클래스속성
                // 일반적으로 자바스크립트는 클래스속성이 className 속성값에 들어간다
                // className이 0부터 시작이라서 ++i 해줘야함
                // el.className = `highlight-${++i}`;

                console.log(this);
                // this 키워드를 배웠기 때문에 현재 돌고있는 function 자기자신으로도 접근가능

            });

        });

    </script>
</body>

</html>