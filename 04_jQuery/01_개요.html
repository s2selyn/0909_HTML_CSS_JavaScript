<!DOCTYPE html>
<html lang="en">

<head>
    <title>jQuery</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
</head>

<body>

    <h1>이히히히히ㅣ히 ㅎ이히잏잏이ㅣㅇ히</h1>

    <a href="https://jquery.com" target="_blank">jQuery란 무엇인가</a>

    <!-- 자바스크립트로 코드를 짜면 마소에서 만든 IE랑 구글에서 만든 크롬이랑 브라우저에서 똑같은 코드로 동작하지 않음
    표준이벤트모델에서 썼던 addEventListner는 구버전 IE에서 동작안함, 크롬에서 달아버리면 IE에서 동작하지않으니 이걸 위해서 기본이나 인라인 방식으로 추가작업을 했어야함
    앞단 개발자 작업이 브라우저마다 개수가 늘어나는 큰 문제
    크로스 브라우저(크로스 브라우징)은 웹접근성에서 이어지는것, 성별나이인종 다 상관없이 모두 똑같이 웹서비스를 이용할 수 있어야지
    완전 똑같은 사람이 이용하는데 브라우저에 따라 동작이 달라지면 웹접근성에 위배되죠, 브라우저마다 작업해야하니까 작업량이 늘어남
    익스플로러가 악명높고 크롬이 베이스, 애플사파리도 싫어잉
    아무튼 이런 문제를 해결할 필요성, 브라우저가 다르니 어쩔수없어서 선구자가 나타남 존레식아저씨
    이아저씨 검색하면 바로 jQuery 얘기 나옴, 브라우저마다 다른 JS 코드 쓰는게 힘들었따.. 요새는 해결됐지만 그때당시에는 번거로움
    이아저씨가 총대메고 라이브러리를 만들어서 하나만 쓰면 어떤 브라우저든 똑같이 동작하게 만들자 해서 jQuery가 만들어짐
    재작년까지만해도 이아저씨 직업이 구글에 창시자로 적혀있었다네요
    웹사이트 90% 정도가 jQ를 사용중, 그만큼 전세계적으로 모든 웹사이트에 jQ라이브러리가 오랜시간 강력한 영향력으로 사용됨
    단순히는 if문에 따라 하나의 함수를 호출해서 모든 브라우저에서 동작하도록 함수모음집으로 만든것
    익혀놔야 회사가서 jQ 100% 있을거니 그걸 유지보수하거나 migration하거나 할수있게됨
    현실에서 jQ 새로 도입하는건 어려움? 생각해볼 여지가 많음
    아무튼 너무 오래 사용되었기 때문에 어쩔수없이 배운다
    -->

    <p>
        기존 자바스크립트만으로는 브라우저마다 각기 다른 코드를 작성해서 <br />
        브라우저를 조작해야하는 어려움이 존재했음 <br />
        <!-- 개발생산성이 떨어지는것, 사람이 더 투입되어야함, 회사입장에서 인건비 증가, 프로젝트 개발비용 총액증가, 생산성 향상을 위해서 -->
        "존레식"은 이런 문제를 해결하기 위해 JavaScript 기반의
        라이브러리를 만들었는데, 그것이 바로 jQuery <br />
        <!-- 그냥 함수모음집 -->
        즉, JavaScript를 이용한 유용한 함수 모음집 <br />

        - jQuery쓰면 뭐가 좋나요? <br />
        1) DOM요소와 관련된 스크립트들을 쉽게 구현할 수 있음 <br />
        2) AJAX(비동기식 통신), 이벤트 처리 등을 쉽게 지원한다. <br />
        <!-- ??? 9:25 jQuery에 맞춘 개발 -->
        3) jQuery와 관련된 확장 플러그인, OPEN API등이 많이 지원된다. <br />

        => 쪼끔 쓰고, 많은 기능을 구현할 수 있음!
    </p>

    <hr />

    <!-- 우리가 사용했던 대표적인 라이브러리 ojdbc도 큰 틀에서 보면 함수 모음집
    ??? 9:27 stmt pstmt exucutequery 등, 프로젝트 build path에 라이브러리 추가해서 사용했음
    jQuery도 HTML문서와 연결하는 과정 필요 -->

    <h3>* jQuery라이브러리 연결 방법</h3>
    <!-- ??? jQuery -->

    <!-- ??? CDN (Content Delivery Network?) 방식(넷플릭스 예시) -->

    <!-- Google CDN 서버를 이용해보자 -->
    <!-- 제일 최근 버전인 3.7.1 써보자 근데 얘도 릴리즈 오래됨 -->
    <!-- 복사해와서 head 영역에 붙여넣기 후 저장 -->
    <!-- 헤드태그에 스크립트 두면 인터넷 환경에서 연결되면 얘가 스크립트 파일을 받아와서
    안의 함수를 HTML에서 호출해서 사용할 수 있음(다운로드랑 비슷함, 요청보내서 응답받으면 함수들이 돌아오는것)
    HTML 라이브서버에서 열고 개발자도구 열어보면 받아오는거 확인됨
    -->

    <p>head영역에 script태그를 이용해서 jQuery관련 .js파일 가져오기</p>

    <!-- 그럼 준비 끝! 실제 사용해보기 -->
    <hr />

    <h3>* jQuery사용해보기</h3>

    <!-- ??? 9:44 head 영역에서 읽어오고 사용은 body에서 함
    head가 먼저 생성되고 body는 생성되지 않아서 선택이 안될수도 있음 -->
    <p>
        <strong>
            우리는 jQuery구문을 이용해서 DOM요소객체를 다룰 예정 <br />
            <!-- 자바스크립트 변수파트에서 전역변수할때 써보긴함 -->
            jQuery구문이 문서상 모든 요소들이 전부 다 로드 된 후에
            실행할 수 있도록 만들어주어야함 => window.onload
        </strong>
    </p>

    <pre>
        순수 자바스크립트에서 해당 내용
        [표현법]
        window.onload = function() {
            실행내용;
        }

        <!-- ??? 9:46 예시, onload 원리 -->
        onload : 페이지가 전부 다 로딩되고나면 자동으로 딱 한 번 수행(될 핸들러를 달아놓는 것)
        해당 HTML문서의 요소들도 다 로딩되고 연동되어있는 외부문서들도(ㅇㅅㅇ???)
        전부 다 로딩된 후에 대입한 이벤트 핸들러가 수행되는 특징을 가짐
        window.onload는 (값을 대입하는 것이기 때문에???) 해당 HTML문서에서 딱 한번만 수행 가능!
    </pre>

    <script>
        /*
        window.onload = function() {
            console.log("안녕하세요");
        };

        // 다른것도 추가하고 싶어서 이런다면?
        window.onload = function() {
            console.log("반갑습니다.");
        }; // 딱 한번 수행되기 때문에 아래쪽에 있는것을 읽어서 이게 다시 대입된다, 위의것은 덮어쓰기되어서 수행되지않음
        // 반갑습니다만 나온다, 아래것이 위의것을 먹고 끝
        */
    </script>

    <!-- ??? 9:49 어떤 상황에서? -->
    <pre>
        - jQery에서는(똑같은 작업을 해야 할 때???) 해당 내용을 세 가지 구문을 통해 제공

        [ 표현법 ]

        <!-- jQuery 키워드 자체를 변수로 선언해뒀음, jQuery를 붙여서 함수를 호출할 수 있음 -->
        1)
        <!-- document객체 선택 후 참조해서 ready()메소드 호출, ready 내부에 대입할 익명함수 작성하고 실행내용을 작성 -->
        jQuery(document).ready(function(){
            실행내용;
        });
        <!-- 도큐먼트 닷 레디 펑션 이라고 부름 -->
        <!-- 이렇게 쓰다 오타 많이나고 불편해서 쉬운방법좀 찡찡해서 존레식씨가 찡찡이들을 위해 $도 가능하게 해줌 -->
        
        2)
        $(document).ready(function(){
            실행내용;
        });

        $: jQuery키워드를 나타냄
        <!-- 전역변수로 설정되어 있음 -->

        <!-- 어차피 이렇게 써야하는거 (document).ready 이것좀 어떻게 해줘요 찡찡
        근데 또해줌 $(function)만 해도 되게 만들어줌 -->
        
        3)
        $(function(){
            실행내용;
        });

        <!-- 전부 문서 전체가 로딩되면 이라는 의미 -->
        <!-- 3번 방법으로 쓰면 되고 옛날방법도 보면 알아야하니까 기억하기 -->
        
        jQuery에서 해당 function은 HTML문서안에 있는 DOM요소들만
        로드되면 바로 실행됨!!!
        (window.onload와의 차이) 여러번 기술 가능, 횟수 제한 없음~!!
    </pre>

    <script>

        /* 위에서 했던 window.onload = function(){실행내용} 이걸 jQuery 버전으로 바꿔보자 */
        $(function () {
            console.log("문서 로딩완료~");
        });
        // window.onload랑 똑같이 동작

        // window.onload는 한번만 동작(맨아래걸로 덮어쓰기됨)
        $(function () {
            console.log("문서로딩완료 끝 ~ ");
        });
        // jQuery는 둘 다 동작함

        // 문서에 많은 pre 요소가지고 놀아보자
        $(function () {

            // 현재 HTML문서에 존재하는 모든 pre요소를 선택해서
            // 배경색을 노란색으로 변경

            // 자바스크립트 방식
            // 선택 먼저
            /*
            const pre = document.getElementsByTagName("pre");
            console.log(pre);
            */
            // 배열 형태로 값이 돌아온다

            // 각 요소에 접근해서 색을 변경해야함
            /*
            pre[0].style.backgroundColor = "yellow";
            pre[1].style.backgroundColor = "yellow";
            */
            // 이런 작업의 문제 -> 추후 생긴 pre 요소는 반영안됨
            // 자바스크립트 이렇게 쓰면 유지보수 측면에 문제가 있음
            // 나중에 생긴 pre 요소를 위해서 반복문 사용(자바식 또는 for of문)
            /*
            for(let i = 0; i < pre.length; i++) {
                pre[i].style.backgroundColor = "yellow";
            };

            for(let el of pre) {
                el.style.backgroundColor = "yellow";
            };
            */

            // jQuery방식
            // ??? 10:18 $ + ("선택할 태그명") + css 메소드 호출하면서 인자값으로 속성명, 값 전달
            $("pre").css("background", "yellow");

            // $("CSS선택자") : 해당 요소를 선택하겠다.
            // .css() : 선택된 요소들의 스타일과 관련된 기능을 수행

            // h3태그들의 글자색을 red로 바꾸겠다.
            // 자바스크립트 방식
            /*
            const h3 = document.querySelectorAll("h3");
            for(let i = 0; i < h3.length; i++) {

                h3[i].style.color = "red";
                // 요소선택, 차곡차곡 접근, 값 바꾸는 방식

            };
            */

            // jQuery방식
            $("h3").css("color", "red");
            // h3 선택하면서 css style의 color 속성을 red로 변경하겠다는 의미

        })

        // 오늘날의 회사들, 웹개발에서는 jQuery 신규도입이 이건 좀... 이라고 됨
        // 이유 1. 자바스크립트라는 언어가 좋아짐
        // JS 쓰면 원래 놀림받는 언어였음, 언어 피드백이 빠름, 불편 필요 등을 반영잘해줘서 발전이 빠름
        // 옛날보다 오늘날이 천지개벽수준으로 바뀜
        // 순수 자바스크립트로 하기 어려운 작업들을 이제는 다 할수있게됨
        // 그것때문에 jQ쓴것은? 함수 내부에서 순수 JS로 변환하는 연산, 시간 추가됨
        // 현재는 동작 속도 차이가 최대 20배 정도 남
        // 순수 자바스크립트는 바닐라 자바스크립트라고 함
        // 사람들 1초만 느려도 답답해하잖아여? 연구결과로는 화면렌더링 1초 증가할때마다 이탈 1% 증가
        // 요새는 앞단 작업할 때 리액트, 앵글러, 뷰 등 외부 라이브러리 프레임워크 많이 사용하는데 이러면 초기로딩시간이 좀 있음
        // 에어비앤비 리액트로 만든건데 회색이 보이는 시간이 있음, 데이터 읽어오는 시간임
        // 여기다 jQ 추가하면 초기시간 + jQ 로딩시간 해서 시간 배가 됨
        // 순수 jQ면 뭐 할수있겠는데 여기 리액트 이런거 붙여버리면 사람들이 버티지 못하고 돔황챠
        // 저런 개발 한다면 jQ 무조건 안쓰는 추세, 나쁜게 아니라 속도가 오래걸리는 성능이슈
        // 오늘날 그렇게까지 중요도가 높고 꼭알아야하는 친구가 아님, 회사가면 무조건 있을테니 혹시모를 유지보수를 위해 배워서 쓸줄은 알아야함

    </script>

    <pre>하하 더생겼다 ~</pre>

</body>

</html>